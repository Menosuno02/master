--	Comentarios
/*
Más de una línea
*/
SELECT * FROM EMP;
SELECT EMP_NO, APELLIDO, OFICIO FROM EMP; -- más eficiente




--	Ordenación
SELECT *
FROM EMP
ORDER BY APELLIDO;

SELECT *
FROM EMP
ORDER BY APELLIDO, SALARIO DESC;




--	Filtrado (=, <>, <=, <, >=, >)
--	Todo lo que no sea un int se compara con comillas simples
--	SQL Server no es case sensitive
--	Operadores relaciones -> AND, OR, NOT
--	Siempre operadores en lugar de negación (NOT)
SELECT *
FROM EMP
WHERE OFICIO <> 'EMPLEADO'
AND SALARIO > 250000;

SELECT *
FROM EMP
WHERE DEPT_NO = 10
OR DEPT_NO = 20;




--	BETWEEN
SELECT *
FROM EMP
WHERE SALARIO BETWEEN 200000 AND 300000;




--	IN, NOT IN
SELECT *
FROM EMP
WHERE DEPT_NO IN (10,20,40,50);

SELECT *
FROM EMP
WHERE DEPT_NO NOT IN (10,20);




--	LIKE
--	_ CARACTER CUALQUIERA
--	? CARACTER NUMERICO
--	% CUALQUIER CARACTER O LONGITUD
SELECT *
FROM EMP
WHERE APELLIDO LIKE '_O%' -- segunda letra es O
OR APELLIDO LIKE '%A%' -- contiene una A
OR APELLIDO LIKE 'A%' -- empieza por A
OR APELLIDO LIKE '____'; -- apellido de 4 letras




--	CAMPOS CALCULADOS
--	Son campos que se calcular a  partir de datos de la tabla
--	No existen en la BBDD
--	Todos deben ser distintos de su name
--	Un cursor no puede tener nombres de campos repetidos, debemos utilizar alias.
--	Tampoco pueden estar las columnas sin nombre

SELECT APELLIDO, SALARIO + COMISION AS TOTAL_SALARIO
FROM EMP;
-- Campos calculados con textos, concatenar strings/nvarchar con + no es estándar
SELECT APELLIDO + ' ' + OFICIO AS DESCRIPCION
FROM EMP;
-- No podemos aplicar filtros a campos calculados, WHERE solo filtra campos de tabla
SELECT APELLIDO, SALARIO + COMISION AS TOTAL
FROM EMP
-- WHERE TOTAL > 300000; INCORRECTO
WHERE SALARIO + COMISION > 300000;
-- Podemos utilizar el alias de un campo calculado en ORDER BY porque ordena los resultados del cursos
SELECT APELLIDO, SALARIO+COMISION AS TOTAL
FROM EMP
WHERE SALARIO + COMISION > 300000
ORDER BY TOTAL;




-- DISTINCT, elimina resultados repetidos de una columna
SELECT DISTINCT(OFICIO)
FROM EMP;




-- Consultas de agrupación
SELECT COUNT(*) AS NUM_DEPT
FROM DEPT;
SELECT MAX(SALARIO) AS MAX_SALAR, MIN(SALARIO) AS MIN_SALAR, APELLIDO
FROM EMP
GROUP BY APELLIDO;
--  GROUP BY para agrupar por columnas, usar por cada columna del SELECT que no sea una función
SELECT COUNT(*) AS PERSONAS, OFICIO
FROM EMP
GROUP BY OFICIO;

SELECT MAX(SALARIO) AS MAX_SALAR, OFICIO, DEPT_NO
FROM EMP
GROUP BY OFICIO, DEPT_NO;

-- Filtros en agrupaciones
--	WHERE: se aplica a columnas de la tabla
--	HAVING: se aplica a columnas y al SELECT, después del GROUP BY
SELECT DEPT_NO, COUNT(*) AS PERSONAS, SUM(SALARIO) AS SUM_SALAR
FROM EMP
WHERE OFICIO = 'DIRECTOR'
GROUP BY DEPT_NO
HAVING SUM(SALARIO) >= 350000;

-- HAVING es más eficiente usando campos que WHERE
SELECT DEPT_NO, COUNT(*) AS PERSONAS
FROM EMP
-- WHERE DEPT_NO IN (10,20)
GROUP BY DEPT_NO
HAVING DEPT_NO IN (10,20);

SELECT DEPT_NO, COUNT(*) AS PERSONAS
FROM EMP
GROUP BY DEPT_NO
HAVING COUNT(*) > 4;




-- Consultas de combinación
SELECT EMP.APELLIDO, EMP.OFICIO, DEPT.DNOMBRE
FROM EMP INNER JOIN DEPT
ON EMP.DEPT_NO = DEPT.DEPT_NO;

-- Podemos usar alias si el nombre de las tablas son muy largos
SELECT E.APELLIDO, E.OFICIO, D.DNOMBRE
FROM EMP E INNER JOIN DEPT D
ON E.DEPT_NO = D.DEPT_NO
WHERE D.DNOMBRE = 'VENTAS';

SELECT SUM(EMP.SALARIO) AS SUMA_SALAR,
DEPT.LOC AS LOCALIDAD
FROM EMP INNER JOIN DEPT
ON EMP.DEPT_NO = DEPT.DEPT_NO
GROUP BY DEPT.LOC;

SELECT DISTINCT(DEPT_NO)
FROM EMP;

-- Forzamos a mostrar empleados aunque no combinen con departamentos
SELECT DEPT.DNOMBRE, EMP.APELLIDO, EMP.OFICIO
FROM EMP RIGHT JOIN DEPT
ON EMP.DEPT_NO = DEPT.DEPT_NO;

SELECT DEPT.DNOMBRE, EMP.APELLIDO, EMP.OFICIO
FROM EMP CROSS JOIN DEPT;

SELECT D.DNOMBRE, COUNT(E.APELLIDO) AS EMPLEADOS
FROM EMP E RIGHT JOIN DEPT D
ON E.DEPT_NO = D.DEPT_NO
GROUP BY D.DNOMBRE;

--	Combinación de más de 2 tablas: PLANTILLA <- HOSPITAL -> SALA
SELECT P.APELLIDO, P.FUNCION, H.NOMBRE AS HOSP_NOMBRE, H.DIRECCION, S.NOMBRE AS SALA_NOMBRE
FROM HOSPITAL H
INNER JOIN PLANTILLA P
ON P.HOSPITAL_COD = H.HOSPITAL_COD
INNER JOIN SALA S
ON S.HOSPITAL_COD = H.HOSPITAL_COD
AND S.SALA_COD = P.SALA_COD;




--	Subconsultas
SELECT *
FROM EMP
WHERE SALARIO = (SELECT MAX(SALARIO)
				 FROM EMP);

SELECT *
FROM EMP
WHERE OFICIO LIKE (SELECT OFICIO
				   FROM EMP
				   WHERE APELLIDO = 'SANCHA');

-- Usar IN si la subconsulta devuelve más de un valor
SELECT *
FROM EMP
WHERE OFICIO IN (SELECT OFICIO
				 FROM EMP
				 WHERE APELLIDO = 'SANCHA'
				 OR APELLIDO = 'ARROYO');




-- Consultas UNION (2 o más)
SELECT APELLIDO, OFICIO, SALARIO AS SUELDO
FROM EMP
UNION
SELECT APELLIDO, FUNCION, SALARIO
FROM PLANTILLA
UNION
SELECT APELLIDO, ESPECIALIDAD, SALARIO
FROM DOCTOR;

-- El ORDER BY se aplica a todas, pero debemos filtrar cada una
SELECT APELLIDO, OFICIO, SALARIO AS SUELDO
FROM EMP
WHERE SALARIO > 220000
UNION
SELECT APELLIDO, FUNCION, SALARIO
FROM PLANTILLA
WHERE SALARIO > 220000
UNION
SELECT APELLIDO, ESPECIALIDAD, SALARIO
FROM DOCTOR
WHERE SALARIO > 220000
ORDER BY SALARIO;

-- Nuestros propios datos
SELECT APELLIDO, OFICIO, SALARIO, 'EMP' AS TABLA
FROM EMP
UNION
SELECT APELLIDO, FUNCION, SALARIO, 'PLANTILLA'
FROM PLANTILLA
UNION
SELECT APELLIDO, ESPECIALIDAD, SALARIO, 'DOCTOR'
FROM DOCTOR;

--	Datos repetidos
SELECT APELLIDO, SALARIO
FROM EMP
UNION ALL
SELECT APELLIDO, SALARIO
FROM EMP




--	SELECT to SELECT
SELECT * FROM
(SELECT APELLIDO, OFICIO, SALARIO AS SUELDO
FROM EMP
UNION
SELECT APELLIDO, FUNCION, SALARIO
FROM PLANTILLA
UNION
SELECT APELLIDO, ESPECIALIDAD, SALARIO
FROM DOCTOR) AS QUERY
WHERE QUERY.SUELDO >= 220000;




--	Consultas a nivel de fila
SELECT APELLIDO, FUNCION, 
CASE T
	WHEN 'M' THEN 'MAÑANA'
	WHEN 'N' THEN 'NOCHE'
	ELSE 'TARDE'
	END AS TURNO
FROM PLANTILLA;

SELECT * FROM
(SELECT APELLIDO, FUNCION, 
CASE T
	WHEN 'M' THEN 'MAÑANA'
	WHEN 'N' THEN 'NOCHE'
	ELSE 'TARDE'
	END AS TURNO
FROM PLANTILLA) QUERY
WHERE QUERY.TURNO = 'NOCHE';




--	INSERT
INSERT INTO DEPT VALUES (50, 'INFORMÁTICA', 'GIJON');
INSERT INTO DEPT (DEPT_NO,LOC) VALUES (60, 'OVIEDO');
SELECT * FROM DEPT;

INSERT INTO DEPT VALUES
((SELECT MAX(DEPT_NO) + 1 FROM DEPT),
'ALGORITMOS', 'SEVILLA');

--	INSERT..INTO
--	La tabla destino debe existir y tener los mismos campos
--	Tipo de dato que el SELECT de origen
INSERT INTO DEPARTAMENTOS
SELECT * FROM DEPT
--	SELECT..INTO
--	Crea una tabla de destino con la misma estructura que el SELECT
--	Si la tabla existe, no podemos ejecutar esta consulta
SELECT * INTO DEPARTAMENTOS
FROM DEPT
SELECT * FROM DEPARTAMENTOS




--	DELETE
SELECT * FROM DEPARTAMENTOS
DELETE FROM DEPARTAMENTOS
WHERE LOC = 'OVIEDO';
--	IS cuando usamos NULL
DELETE FROM DEPARTAMENTOS
WHERE DNOMBRE IS NULL;

--	Eliminar empleados del dept. de produccion
DELETE FROM EMP
WHERE DEPT_NO = (SELECT DEPT_NO
				 FROM DEPT
				 WHERE DNOMBRE = 'PRODUCCION');




--	UPDATE
UPDATE DEPT
SET LOC = 'TABARNIA'
WHERE LOC = 'BARCELONA';

UPDATE EMP
SET SALARIO = SALARIO + 1
WHERE OFICIO = 'DIRECTOR';

--	Podemos usar subconsultas en SET y WHERE
UPDATE EMP
SET SALARIO = SALARIO + 1
WHERE DEPT_NO = (SELECT DEPT_NO
				 FROM DEPT
				 WHERE LOC = 'TABARNIA');

UPDATE EMP
SET SALARIO = (SELECT SALARIO
				FROM EMP
				WHERE APELLIDO = 'ALONSO')
WHERE DEPT_NO = (SELECT DEPT_NO
				 FROM DEPT
				 WHERE LOC = 'TABARNIA');